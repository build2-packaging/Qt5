#!/usr/bin/env bash

# file      : generate
# license   : MIT

# Create the infrastructure required by our Qt packages:
#
# - Create a source layout more suitable to our purposes which is still
#   compatible with the Qt upstream (the way they include stuff, etc).
#
# - Separate private headers to a deeper directory subtree to prevent them
#   from being found without the addition of the header search directories
#   exported by the lib{Qt5CorePrivate} and similar targets.
#
#   For QtGui, for example, the public headers are under libQt5Gui/QtGui/
#   while the private headers are under
#   libQt5Gui/QtGui/private/QtGui/{private,qpa}/. Thus include paths such as
#   <QtGui/private/foo_p.h> or <private/foo_p.h> will not work without
#   lib{Qt5GuiPrivate}'s exported poptions of "-IlibQt5Gui/QtGui/private
#   -IlibQt5Gui/QtGui/private/QtGui".
#
# - Most upstream files are symlinked into our source layout but in some cases
#   this is not possible. The upstream build runs a script, syncqt.pl, for
#   each module which rearranges its public headers to be fit for consumption
#   by their clients (other Qt modules and Qt users). For example, it
#   generates camelcase-named versions of the public headers and groups
#   headers from different source subdirectories into the same directory, the
#   name of which clients then use in their include paths. Because these
#   conversions are not trivial enough to reproduce here we cannot symlink to
#   the original sources so we copy them from the script's output directories
#   instead.
#

owd="$(pwd)"
trap "{ cd '$owd'; exit 1; }" ERR
set -o errtrace     # Trap in functions and subshells.
set -o pipefail     # Fail if any pipeline command fails.
shopt -s lastpipe   # Execute last pipeline command in the current shell.
shopt -s nullglob   # Expand no-match globs to nothing rather than themselves.

function info () { echo "$*" 1>&2; }
function error () { info "$*"; exit 1; }

# Recursively remove all files in <dir> that are symlinks.
#
function rm_symlinks () # <dir>
{
  find "$1" -type l -exec rm {} \;
}

# Recursively remove all empty directories in <dir>.
#
function rm_empty_dirs () # <dir>
{
  local d="${1%/}"

  local sd # Subdirectory.
  for sd in "$d"/*/; do
    # Remove subdirectory contents, then remove subdirectory itself if empty.
    #
    if [[ -d "$sd" ]]; then
      rm_empty_dirs "$sd"
    fi

    if [[ -z "$(ls "$sd")" ]]; then
      rmdir "$sd"
    fi
  done
}

# Remove previously-generated files and directories.
#
rm_symlinks Qt5Moc/moc/
rm_empty_dirs Qt5Moc/moc/

rm_symlinks Qt5Rcc/rcc/
rm_empty_dirs Qt5Rcc/rcc/

rm_symlinks libQt5Core/QtCore/
rm_empty_dirs libQt5Core/QtCore/
rm -f  libQt5Core/QtCore/Q*
rm -rf libQt5Core/3rdparty

rm_symlinks libQt5Gui/QtGui/
rm_empty_dirs libQt5Gui/QtGui/
rm -rf libQt5Gui/3rdparty
rm -f  libQt5Gui/mkspecs
# Remove copied headers (generated by syncqt.pl).
#
rm -rf libQt5Gui/QtGui/qpa/
rm -rf libQt5Gui/QtGui/private/QtGui/qpa/
rm -f   libQt5Gui/QtGui/Q*

rm_symlinks libQt5Gui/QtGuiPlugins/
rm_empty_dirs libQt5Gui/QtGuiPlugins/
rm -rf libQt5Gui/QtGuiPlugins/{Qt*Support,QtPlatformHeaders}

# Create output directories.
#
# 3rdparty/ has to be a sibling to QtCore/ because the QtCore source files use
# include paths such as "../../3rdparty/freebsd/strtoll.c".
#
mkdir Qt5Moc/moc/3rdparty
mkdir Qt5Moc/moc/QtCore
mkdir Qt5Moc/moc/QtCore/private
mkdir Qt5Moc/moc/QtCore/private/QtCore
mkdir Qt5Moc/moc/QtCore/private/QtCore/private

mkdir Qt5Rcc/rcc/3rdparty
mkdir Qt5Rcc/rcc/QtCore
mkdir Qt5Rcc/rcc/QtCore/private
mkdir Qt5Rcc/rcc/QtCore/private/QtCore
mkdir Qt5Rcc/rcc/QtCore/private/QtCore/private

mkdir libQt5Core/3rdparty
# Directory for the MIME type database source XML file.
#
mkdir libQt5Core/QtCore/mimetypes
mkdir libQt5Core/QtCore/mimetypes/mime
mkdir libQt5Core/QtCore/mimetypes/mime/packages

mkdir libQt5Gui/3rdparty
mkdir libQt5Gui/QtGui/qpa
mkdir libQt5Gui/QtGui/private/QtGui/qpa

# Symlink the upstream platform-specific include directories.
#
ln -s ../../upstream/qtbase/mkspecs Qt5Moc/moc/
ln -s ../../upstream/qtbase/mkspecs Qt5Rcc/rcc/
ln -s ../../upstream/qtbase/mkspecs libQt5Core/QtCore/
ln -s ../upstream/qtbase/mkspecs libQt5Gui/

# Symlink the upstream third-party directories.
#
ln -s ../../../upstream/qtbase/src/3rdparty/{freebsd,sha1} \
   Qt5Moc/moc/3rdparty/
ln -s ../../../upstream/qtbase/src/3rdparty/{freebsd,sha1} \
   Qt5Rcc/rcc/3rdparty/
ln -s ../../upstream/qtbase/src/3rdparty/{easing,freebsd,forkfd,md4,md5,rfc6234,sha1,sha3,harfbuzz} \
   libQt5Core/3rdparty/
ln -s ../../upstream/qtbase/src/3rdparty/icc \
   libQt5Gui/3rdparty/

# This is made necessary by the inclusion of
# "../testlib/3rdparty/valgrind_p.h" by corelib/tools/qsimd.cpp. (That is,
# QtCore includes a private header from QTestLib, an entirely different
# library...)
#
ln -sf ../../upstream/qtbase/src/testlib libQt5Core/QtCore/

# Symlink an upstream source file into our project directory structure.
#
# If there is a downstream version of the source file, its symlink gets the
# upstream filename while the upstream original's symlink gets the upstream
# filename with a ".orig" extension.
#
# <symlink-target-path>: path to the symlink's upstream target, relative to
#                        the destination directory (so will contain some
#                        `../`s).
#
# <destination-dir-path>: path to the directory that will contain the symlink,
#                         relative to the project root.
#
# For example, assuming downstream/foo/bar/baz.cpp exists:
#
#   call:   symlink_source_file ../../upstream/foo/bar/baz.cpp foo/bar/
#   result: foo/bar/baz.cpp      -> downstream/foo/bar/baz.cpp
#           foo/bar/baz.cpp.orig ->   upstream/foo/bar/baz.cpp
#
function symlink_source_file () # <symlink-target-path> <destination-dir-path>
{
  local ut="${1%/}" # Upstream symlink target path.
  local d="${2%/}"  # Destination directory path.

  local fn="$(basename "$ut")" # Upstream target file name.

  # Path to the downstream version of the symlink target, relative to the
  # destination directory. (Don't use sed because doing so for every file is
  # too slow).
  #
  local dt="${ut/upstream/downstream}" # Downstream symlink target path.

  if [[ -f "$d/$dt" ]]; then
    ln -sf "$ut" "$d/$fn.orig"
    ln -sf "$dt" "$d/$fn"
  else
    ln -sf "$ut" "$d/$fn"
  fi
}

# Symlink the moc and rcc applications' headers and source files into
# Qt5Moc/moc/ and Qt5Rcc/rcc/. Unlike Qt modules such as QtCore and QtGui (see
# below), these tools' source files and headers are all in the same directory.
#
for f in upstream/qtbase/src/tools/moc/*.{h,cpp}; do
  symlink_source_file "../../$f" Qt5Moc/moc/
done

for f in upstream/qtbase/src/tools/rcc/*.{h,cpp}; do
  symlink_source_file "../../$f" Qt5Rcc/rcc/
done

# Symlink all of a Qt module's sources into
# <output-path-prefix>/<module-name>/.
#
# Note that we have to rearrange the upstream sources because they cannot be
# built the way they're laid out in upstream/qtbase/src/<module> (the upstream
# build also rearranges them).
#
# From the upstream directory layout:
#
#   upstream/qtbase/src/modulename
#   ├── foo
#   │   ├── foo.cpp
#   │   ├── foo.h
#   │   ├── foo_p.h
#   │   ...
#   ├── bar
#   │   ├── bar.cpp
#   │   ├── bar.h
#   │   ├── bar_p.h
#   │   ...
#   ...
#
# create the following layout:
#
#   <output-path-prefix>
#    └── QtModuleName
#        ├── foo
#        │   ├── foo.cpp
#        │   ...
#        ├── bar
#        │   ├── bar.cpp
#        │   ...
#        ├── private
#        │   ├── foo_p.h
#        │   ├── bar_p.h
#        │   ...
#        ├── foo.h
#        ├── bar.h
#        ...
#
function symlink_module_subdir ()
# <output-path-prefix> <module-name> <subdir>
{
  local opp="$1"   # Output path prefix.
  local mod="$2"   # Qt module name.
  local d="${3%/}" # Module subdirectory from upstream (strip trailing /).

  # Project directory path: the relative path to get to the project directory
  # from the output path prefix (`opp`). For example, from Qt5Moc/moc/ it
  # would be `../..`.
  #
  local pdp="$(sed -E 's%[^/]+%..%g' <<<"$opp")"
  local sdd="$opp/$mod/$(basename $d)" # Source file destination directory.
  mkdir -p "$sdd"

  # All of the source files of interest are directly under one of
  # src/<module>/'s subdirectories (that is, nested no deeper).
  #
  local f
  for f in "$d"/*; do
    tpp= # Symlink target path prefix.
    spp= # Symlink path prefix.

    case "$f" in
      # Private header.
      #
      *_p.h)
        tpp="$pdp/../../../.."
        spp="$opp/$mod/private/$mod/private"
        ;;
      # Public header.
      #
      *.h)
        tpp="$pdp/.."
        spp="$opp/$mod"
        ;;
      # C++, Objective-C++, or C source file.
      #
      *.cpp | *.mm | *.c)
        tpp="$pdp/../.."
        spp="$sdd"
        ;;
      # Not a source file.
      #
      *) continue ;;
    esac

    symlink_source_file "$tpp/$f" "$spp"
  done

  # Remove the source file destination directory if it is empty (which would
  # be the case if the upstream directory contained no source files).
  #
  if [[ -z "$(ls "$sdd")" ]]; then
    rmdir "$sdd"
  fi
}

# Symlink the upstream QtCore sources into Qt5Moc/, Qt5Rcc/, and
# libQt5Core/. Although the Qt5Moc and Qt5Rcc builds include only a subset of
# the QtCore sources we symlink all of them for the sake of simplicity (their
# buildfiles do not use wildcards).
#
for d in upstream/qtbase/src/corelib/*/; do
  symlink_module_subdir Qt5Moc/moc QtCore "$d"
  symlink_module_subdir Qt5Rcc/rcc QtCore "$d"
  symlink_module_subdir libQt5Core QtCore "$d"
done

# Symlink the upstream MIME type database source XML file into libQt5Core/.
#
ln -s ../../../../../\
upstream/qtbase/src/corelib/mimetypes/mime/packages/freedesktop.org.xml \
      libQt5Core/QtCore/mimetypes/mime/packages/

# Symlink the upstream QtGui sources into libQt5Gui/.
#
for d in upstream/qtbase/src/gui/*/; do
  symlink_module_subdir libQt5Gui QtGui "$d"
done

# Remove the QPA headers because they belong under qpa/ (and will be moved
# there below, as per the upstream build).
#
rm libQt5Gui/QtGui/qplatform*.h
rm libQt5Gui/QtGui/private/QtGui/private/qplatform*_p.h

mv libQt5Gui/QtGui/kernel/qguiapplication.cpp \
   libQt5Gui/QtGui/kernel/qguiapplication-install.cpp

# Symlink upstream Qt resources and related files into libQt5Gui/.
#
ln -s ../../../upstream/qtbase/src/gui/painting/qpdf.qrc \
      libQt5Gui/QtGui/painting/
ln -s ../../../upstream/qtbase/src/gui/painting/qpdfa_metadata.xml \
      libQt5Gui/QtGui/painting/
ln -s ../../../upstream/qtbase/src/gui/painting/webgradients.binaryjson \
      libQt5Gui/QtGui/painting/

# Symlink upstream plugin sources.
#
# Note that we don't rearrange plugins' sources as we do those of "proper" Qt
# modules such as QtCore and QtGui because it does not seem worth the trouble
# for the following reasons: 1) The plugin directories have a different layout
# in that there are source files in the plugin root (for example, in
# upstream/qtbase/src/plugins/platforms/xcb/) which is where subdirectory
# headers would be copied to, and 2) in some instances source files are more
# than one directory level down from the root (for example, in
# upstream/qtbase/src/plugins/platforms/xcb/gl_integrations/xcb_egl/). And 3)
# the plugin libraries are loaded at runtime by one of the "proper" Qt modules
# (for example, libQt5Gui loads libqxcb) and are thus not user-facing to the
# same degree.
#
function symlink_plugin_files ()
{
  local s="${1%/}"                  # Source directory.
  local d="${2%/}/$(basename "$s")" # Destination directory.

  # Prefix to make target path relative to the destination directory (one
  # `../` for each directory component in the destination path).
  #
  local tp="$(sed -Ee 's%[^/]+%..%g' <<<"$d")" # Target prefix.

  local t # Target file.
  for t in "$s"/*; do
    case "$t" in
      *.h|*.cpp|*.json)
        symlink_source_file "$tp/$t" "$d"
        ;;
      *)
        if [[ -d "$t" ]]; then
          mkdir -p "$d/$(basename "$t")"
          symlink_plugin_files "$t" "$d"
        fi
    esac
  done
}

symlink_plugin_files upstream/qtbase/src/platformsupport \
                     libQt5Gui/QtGuiPlugins/platforms/

symlink_plugin_files upstream/qtbase/src/plugins/platforms/xcb/ \
                     libQt5Gui/QtGuiPlugins/platforms/

symlink_plugin_files \
  upstream/qtbase/src/plugins/platforminputcontexts/compose/ \
  libQt5Gui/QtGuiPlugins/platforminputcontexts/

# For the imageformats plugins we symlink the source directories, not their
# contents.
#
ln -s ../../../upstream/qtbase/src/plugins/imageformats/gif \
      libQt5Gui/QtGuiPlugins/imageformats/
ln -s ../../../upstream/qtbase/src/plugins/imageformats/ico \
      libQt5Gui/QtGuiPlugins/imageformats/
ln -s ../../../upstream/qtbase/src/plugins/imageformats/jpeg \
      libQt5Gui/QtGuiPlugins/imageformats/

# Extract the Qt version from upstream/qtbase/.qmake.conf.
#
qt_version="$(sed -nE 's%MODULE_VERSION = (.+)%\1%p' \
                  upstream/qtbase/.qmake.conf)"

# Copy headers generated by the upstream build.
#
# The majority of the generated headers are camelcase versions of the public
# headers (foobar.h -> QFooBar) but in some cases headers from different
# subdirectories are placed in the same directory to allow their inclusion
# using a common path prefix.
#
# Run the upstream syncqt.pl script to produce the include tree and copy only
# those headers that don't already exist in the upstream directory (in which
# case they are not generated and will already have been symlinked above).
#

# Run the upstream syncqt.pl script to generate headers for the given Qt
# module in a temporary directory.
#
# Return the path to the temporary directory.
#
function gen_hdrs () # <module-name>
{
  local mod="$1" # Module name.
  local tmpdir="$(mktemp -d)"

  if ! upstream/qtbase/bin/syncqt.pl               \
       -copy -module "$mod" -version "$qt_version" \
       -outdir "$tmpdir" upstream/qtbase           \
       > /dev/null; then
    rm -r "$tmpdir"
    error "syncqt.pl failed"
  fi

  echo "$tmpdir"
}

# Copy headers generated for QtCore into libQt5Core/QtCore/.
#
tmpdir="$(gen_hdrs QtCore)"

for p in "$tmpdir/include/QtCore/"*; do
  f="$(basename "$p")"

  if [[ ("$f" == *.h && ! -e "libQt5Core/QtCore/$f") || "$f" == Q* ]]; then
    cp "$p" libQt5Core/QtCore/
  fi
done

rm -r "$tmpdir"

# This (empty) header is generated by qmake in the upstream build.
#
touch libQt5Core/QtCore/QtCoreDepends

# Copy headers generated for QtGui into libQt5Gui/QtGui/.
#
tmpdir="$(gen_hdrs QtGui)"

# In addition to the generated public *.h and Q* headers as for QtCore, also
# copy the generated QPA (Qt Platform Abstraction) headers.
#
# Note that they are usually included with a `qpa/` prefix so must go into
# their own subdirectory (unlike normal headers).
#
for p in "$tmpdir/include/QtGui/"*; do
  f="$(basename "$p")"

  if [[ ("$f" == *.h && ! -e "libQt5Gui/QtGui/$f") || "$f" == Q* ]]; then
    cp "$p" libQt5Gui/QtGui/
  elif [[ "$f" == "$qt_version" ]]; then
    for p2 in "$p/QtGui/qpa/"*; do
      case "$p2" in
        *_p.h)
          cp "$p2" libQt5Gui/QtGui/private/QtGui/qpa/
          ;;
        *.h)
          cp "$p2" libQt5Gui/QtGui/qpa/
          ;;
      esac
    done
  fi
done

rm -r "$tmpdir"

# This header is generated by qmake in the upstream build.
#
echo "#include <QtCore/QtCore>" > libQt5Gui/QtGui/QtGuiDepends

# Copy headers generated for the platform support modules (required by the
# code in platformsupport/ and the platform plugins via includes such as
# <QtServiceSupport/foo_p.h>) into libQt5Gui/QtGuiPlugins/.
#
# Note: A few of these platform support modules are referenced from outside of
#       libQt5Plugins/platforms/ so they have to reside at a higher level.
#
#       Currently only one out of many camelcase platform support headers
#       (QPlatformHeaderHelper) is actually referenced by the code.
#
for mod in QtPlatformHeaders     \
           QtServiceSupport      \
           QtThemeSupport        \
           QtFontDatabaseSupport \
           QtXkbCommonSupport    \
           QtEdidSupport; do
  tmpdir="$(gen_hdrs "$mod")"

  mkdir "libQt5Gui/QtGuiPlugins/$mod/"

  for p in "$tmpdir/include/$mod/"*; do
    f="$(basename "$p")"

    case "$f" in
      *.h|QPlatformHeaderHelper) # Public header.
        cp "$p" "libQt5Gui/QtGuiPlugins/$mod/"
        ;;
      "$qt_version") # Private header directory.
        cp -r "$p/$mod/private/" "libQt5Gui/QtGuiPlugins/$mod/"
        ;;
    esac
  done

  rm -r "$tmpdir"
done
