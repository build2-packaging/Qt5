import libs = libQt5Widgets%lib{Qt5Widgets}

import! [metadata] moc = Qt5Moc%exe{qt5moc}

exe{gui-app}: hxx{window} cxx{gui-app window} $libs
{
  # Close the window automatically after a few seconds.
  #
  test.options = --auto-close
}

exe{gui-app}:    cxx{moc_window}: include = adhoc
cxx{moc_window}: hxx{window}

# The "metadata libraries": its purpose is to make sure all the imported
# libraries are resolved for the ad hoc moc rules below.
#
# Note: use a rule hint to resolve ambiguity between C and C++ library.
#
[rule_hint=cxx] libul{Qt5WidgetsTestsMeta}: $libs

# -I options for the system header directories.
#
sys_incl = $regex.apply($cxx.sys_hdr_dirs, '(.+)', '-I\1')

import corelib = libQt5Core%lib{Qt5Core}
moc_predefs_path = $($corelib: libQt5Core.moc_predefs_path)

# Rule to run moc on a header file (foo.h -> moc_foo.cpp).
#
cxx{~'/moc_(.*)/'}: hxx{~'/\1/'} libul{Qt5WidgetsTestsMeta} $moc
{{
  o = $path($>[0])
  t = $(o).t

  dep_incl = $cxx.lib_poptions(libul{Qt5WidgetsTestsMeta})

  depdb hash $dep_incl

  # Note: exclude libul{Qt5WidgetsTestsMeta} from update during match not to mess
  #       up its for-install'ness.
  #
  depdb dyndep                                                  \
    --byproduct --drop-cycles --what=header --default-type=h    \
    --update-exclude libul{Qt5WidgetsTestsMeta}                 \
    --file $t

  diag moc ($<[0])

  s = $path($<[0])

  # -i: don't include the header (we don't need it and it's simpler this way).
  #
  $moc --include $moc_predefs_path                      \
    $cc.poptions $cxx.poptions $dep_incl $sys_incl      \
    -i --output-dep-file --dep-file-path $t -o $o $s
}}

cxx.poptions =+ "-I$out_base"
